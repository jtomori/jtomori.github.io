<meta charset="utf-8" lang="en">
<link href="../styles.css" rel="stylesheet">

**Houdini HDAs, versions and git**
[ <- ](..) _draft_

TODO:

- separate the two problems here: how to version tools and where to store python code

# Intro

I am putting here my thoughts on handling versions of Houdini assets (HDA) along a version control system (VCS), like git. I am not sure what is the best approach for that, so you won't find that answer here. I will rather mention possible workflows with their pros and cons. I hope that somebody with more experience will read this post and will let me know of a better way!

It's a pretty abstract topic, but I will try to do illustrations and a sample repo for clarification. 

All issues discussed below are related to tools with significant part implemented in Python. For pure Houdini tools this is less of a problem.

# Background

I have written an [introduction into versioning of HDAs](https://jurajtomori.wordpress.com/2018/07/02/houdini-tip-assets-versioning-workflow/) some time ago. I will assume that you are familiar with the workflow described there.

Houdini docs has more in-depth information:

- [Creating and versioning digital assets](https://www.sidefx.com/docs/houdini/assets/create.html)
- [Digital assets versions and namespaces](https://www.sidefx.com/docs/houdini/assets/namespaces.html)

# Problem

So the thing that is unclear to me is like this: both a VCS and HDAs versions really help with tool development, deployment and usage. However both approaches can be used for HDA versioning alone and I am wondering which is the better one (or how to combine the two).

Here is what I use VCS and HDA versions [^hdaver] for:

- git
 - Not loosing work
 - Using branches for development, experiments
 - Versions with [tagging](https://git-scm.com/book/en/v2/Git-Basics-Tagging) for tool releases and deployment
 - Keeping track of code (mostly Python) changes, which I usually keep outside of the HDA [^hdapy]
- HDAs
 - Namespaces - e.g. for having multiple `Copy` tools
 - Versions, for keeping backward compatibility with existing Houdini scenes and letting users switch the preferred version

I'd like to keep all of the features above, but choosing one or the other for versions comes with a couple of tradeoffs.

There's also an question whether to use a single HDA without the version string, but use git tags for keeping track of a version. Or whether to store multiple asset versions in a single HDA file [^multihda]. Or to do a combination of both?

[^hdaver]: By HDA versions I mean the _version string_ in node's _operator name_, e.g. `1.0.3` in `studio::magic::1.0.3`.

[^hdapy]: I prefer to structure Python code as a [standard Python project](https://realpython.com/python-application-layouts/#installable-single-package), which I then import into the asset and call needed functions. This is in contrast to storing Python code directly in the asset.

[^multihda]: Houdini HDA files (or folders in case of unpacked assets) can store multiple assets with different versions. Houdini then allows users to switch between versions via a dropdown menu in node's asset bar.

# Tradeoffs

## Git

Using git tags for versions is a common workflow in software development. It allows me to version both the python code and HDAs at the same time. It also allows for making tool releases and deployment into users' environment [^houenv].

I am making my tools code-first, thus managing them as Python packages. Majority of the logic is handled by Python code and Houdini HDAs are bundled in the package.

However if I use VCS versioning only for HDA versions, then this breaks existing scenes which might have used an older version of an asset (e.g. opening an older scene with a newer tool installed into the environment).

This is a problem, since I don't want to change a behavior of an older Houdini scene and perhaps I need to use 2 different versions of an asset in one scene. Furthermore I'd like to allow users to switch between asset versions if needed, directly from Houdini interface. Thus without requiring them to change their environment, install packages, down/upgrade etc.

- Pros
 - Code and assets are versioned together in VCS
 - Code-first approach makes the code easier to maintain, test if it's not stored in the HDA
 - A tool has the same structure as other Python projects which might not necessarily be Houdini tools
- Cons
 - Environment upgrade with a newer tool upgrade breaks older scenes
 - Harder to change asset versions, even harder to use both in the same scene

## HDAs

Keeping multiple HDA versions in a single HDA file provides great user experience for users - artists, TDs. Houdini scene preserves which asset version was used, so in the future with newer versions available, Houdini will keep the node at older version. It will also allow an user to upgrade asset's version if new functionality is needed, or downgrade if bugs occur, or previous behavior is preferred.

In case of HDA versioning there's also a question of where to store Python code.

I prefer to store code outside of the assets, this has numerous development advantages over the alternative of storing it inside of the HDA:

- Easier to reuse Python code if it's outside in a module
- Possible to use the Python code without Houdini (and associated license)
- Easier to test Python code
- Easier to diff changes between commits, versions

This however has an disadvantage, which means that code version and HDA versions are decoupled now. I think this is the root of the problem I am describing in this post. To illustrate it, imagine this scenario, asset has a button with callback to `tool.set_parameters_from_db()` Python function. Now 

[^houenv]: By environment I mean the configuration from which the artist launches Houdini. For example which tools at what versions they have available, probably managed via various [environment variables](https://jurajtomori.wordpress.com/2018/01/15/houdini-tip-taking-advantage-of-environment-variables/).

<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="../markdeep.min.js" charset="utf-8"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
